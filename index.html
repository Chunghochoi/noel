<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Christmas Gesture Magic 3D</title>
    
    <!-- Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <style>
        :root {
            --gold: #ffd700;
            --xmas-red: #d42426;
            --xmas-green: #165b33;
            --glass: rgba(255, 255, 255, 0.1);
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background: radial-gradient(circle at center, #1a2a6c, #b21f1f, #fdbb2d);
            background: #050505; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }

        #container { width: 100%; height: 100%; position: relative; }

        /* Camera Feed (Hidden or Miniature) */
        #video-container {
            position: absolute; bottom: 20px; right: 20px;
            width: 120px; height: 90px; border-radius: 10px;
            overflow: hidden; border: 2px solid var(--gold);
            z-index: 10; transform: scaleX(-1);
        }
        video { width: 100%; height: 100%; object-fit: cover; }

        /* UI Overlay */
        .ui-panel {
            position: absolute; top: 20px; left: 20px;
            background: var(--glass); backdrop-filter: blur(15px);
            padding: 20px; border-radius: 15px; border: 1px solid rgba(255,255,255,0.2);
            max-width: 300px; z-index: 100; max-height: 85vh; overflow-y: auto;
        }

        .mobile-toggle { display: none; }

        h1 { font-size: 1.2rem; margin: 0 0 10px 0; color: var(--gold); text-shadow: 0 0 10px rgba(255,215,0,0.5); }
        
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; opacity: 0.8; }
        
        select, input[type="range"], button {
            width: 100%; padding: 8px; border-radius: 5px; border: none;
            background: rgba(255,255,255,0.2); color: white; cursor: pointer;
        }

        button {
            background: var(--xmas-red); font-weight: bold; margin-top: 5px;
            transition: 0.3s;
        }
        button:hover { background: #ff4d4d; }

        .hint-overlay {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            text-align: center; pointer-events: none; transition: opacity 1s;
        }

        /* Mobile specific adjustments */
        @media (max-width: 768px) {
            .ui-panel {
                top: auto; bottom: 0; left: 0; width: 100%; max-width: none;
                border-radius: 20px 20px 0 0; transform: translateY(70%);
                transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            }
            .ui-panel.open { transform: translateY(0); }
            .mobile-toggle {
                display: block; text-align: center; padding: 5px; color: var(--gold);
                font-weight: bold; cursor: pointer;
            }
        }

        .loading-screen {
            position: fixed; inset: 0; background: #000; z-index: 1000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
    </style>
</head>
<body>

    <div class="loading-screen" id="loading">
        <h2 style="color:var(--gold)">Magic is loading...</h2>
        <p>Initializing AI Camera & 3D Snow...</p>
    </div>

    <div id="container">
        <!-- UI -->
        <div class="ui-panel" id="ui">
            <div class="mobile-toggle" onclick="document.getElementById('ui').classList.toggle('open')">â–² Settings & Photos</div>
            <h1>ðŸŽ„ Noel Magic</h1>
            
            <div class="control-group">
                <label>Morph Shape</label>
                <select id="shapeSelect">
                    <option value="sphere">Sphere Cluster</option>
                    <option value="heart">Heart</option>
                    <option value="tree">Christmas Tree</option>
                    <option value="snowflake">Snowflake</option>
                    <option value="saturn">Saturn</option>
                    <option value="flower">Ice Flower</option>
                </select>
            </div>

            <div class="control-group">
                <label>Magic Color</label>
                <input type="color" id="colorPicker" value="#ffffff">
            </div>

            <div class="control-group">
                <label>Particle Size</label>
                <input type="range" id="pSize" min="0.01" max="0.2" step="0.01" value="0.05">
            </div>

            <div class="control-group">
                <label>Couple Photos</label>
                <input type="file" id="photoUpload" accept="image/*" multiple>
                <button onclick="document.getElementById('photoUpload').click()">Upload Photo(s)</button>
            </div>

            <button id="calibrateBtn">Center Gesture</button>
        </div>

        <div class="hint-overlay" id="hint">
            <p>Show one hand to rotate & pinch to scale</p>
            <p style="font-size: 0.8rem; color: var(--gold);">Use two hands to expand/contract</p>
        </div>

        <div id="video-container">
            <video id="input_video"></video>
        </div>
    </div>

    <script>
        /** 
         * GLOBAL VARIABLES & SETUP 
         **/
        let scene, camera, renderer, particles, particleSystem;
        let clock = new THREE.Clock();
        const PARTICLE_COUNT = 8000;
        let targetPositions = [];
        let currentShape = 'sphere';
        let handData = { oneHand: false, twoHands: false, scale: 1, spread: 0, rotation: {x:0, y:0} };
        let photoPlanes = [];

        /** 
         * GENERATE SHAPE MATH 
         **/
        function getShapePoints(shape) {
            const points = [];
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let x, y, z;
                if (shape === 'heart') {
                    const t = Math.random() * Math.PI * 2;
                    x = 16 * Math.pow(Math.sin(t), 3);
                    y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                    z = (Math.random() - 0.5) * 5;
                    points.push(new THREE.Vector3(x * 0.4, y * 0.4, z * 0.4));
                } else if (shape === 'tree') {
                    const h = Math.random() * 20;
                    const r = (20 - h) * 0.4;
                    const theta = Math.random() * Math.PI * 2;
                    x = Math.cos(theta) * r;
                    z = Math.sin(theta) * r;
                    y = h - 10;
                    points.push(new THREE.Vector3(x, y, z));
                } else if (shape === 'snowflake') {
                    const arm = Math.floor(Math.random() * 6);
                    const dist = Math.random() * 15;
                    const angle = (arm * Math.PI * 2) / 6;
                    x = Math.cos(angle) * dist;
                    y = Math.sin(angle) * dist;
                    z = (Math.random() - 0.5) * 2;
                    points.push(new THREE.Vector3(x, y, z));
                } else if (shape === 'saturn') {
                    if (i < PARTICLE_COUNT * 0.7) {
                        const phi = Math.acos(-1 + (2 * i) / (PARTICLE_COUNT * 0.7));
                        const theta = Math.sqrt(PARTICLE_COUNT * 0.7 * Math.PI) * phi;
                        x = 8 * Math.cos(theta) * Math.sin(phi);
                        y = 8 * Math.sin(theta) * Math.sin(phi);
                        z = 8 * Math.cos(phi);
                    } else {
                        const r = 12 + Math.random() * 3;
                        const theta = Math.random() * Math.PI * 2;
                        x = Math.cos(theta) * r;
                        z = Math.sin(theta) * r;
                        y = (Math.random() - 0.5) * 1;
                    }
                    points.push(new THREE.Vector3(x, y, z));
                } else if (shape === 'flower') {
                    const t = Math.random() * Math.PI * 2;
                    const r = 10 * Math.sin(5 * t);
                    x = r * Math.cos(t);
                    y = r * Math.sin(t);
                    z = (Math.random() - 0.5) * 5;
                    points.push(new THREE.Vector3(x, y, z));
                } else { // Sphere
                    const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                    const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                    points.push(new THREE.Vector3(10 * Math.cos(theta) * Math.sin(phi), 10 * Math.sin(theta) * Math.sin(phi), 10 * Math.cos(phi)));
                }
            }
            return points;
        }

        /** 
         * THREE.JS CORE 
         **/
        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);

            // Particle Geometry
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(PARTICLE_COUNT * 3);
            const targets = getShapePoints('sphere');
            
            for(let i=0; i<PARTICLE_COUNT; i++) {
                pos[i*3] = targets[i].x;
                pos[i*3+1] = targets[i].y;
                pos[i*3+2] = targets[i].z;
            }
            
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            
            // Magical Particle Texture (Generated Canvas)
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32,32,0, 32,32,32);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            grad.addColorStop(0.5, 'rgba(255,255,255,0.1)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,64,64);
            const texture = new THREE.CanvasTexture(canvas);

            const mat = new THREE.PointsMaterial({
                size: 0.05,
                map: texture,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                color: 0xffffff
            });

            particleSystem = new THREE.Points(geo, mat);
            scene.add(particleSystem);

            // Lighting for photos
            const ambient = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambient);

            targetPositions = targets;

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /** 
         * PHOTO FEATURE 
         **/
        document.getElementById('photoUpload').addEventListener('change', function(e) {
            const files = e.target.files;
            for (let i = 0; i < files.length; i++) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const loader = new THREE.TextureLoader();
                    loader.load(event.target.result, (texture) => {
                        const aspect = texture.image.width / texture.image.height;
                        const geom = new THREE.PlaneGeometry(8 * aspect, 8);
                        const material = new THREE.MeshBasicMaterial({ 
                            map: texture, 
                            side: THREE.DoubleSide, 
                            transparent: true,
                            opacity: 0.9 
                        });
                        const plane = new THREE.Mesh(geom, material);
                        plane.position.set((i * 10) - 5, 0, 5);
                        scene.add(plane);
                        photoPlanes.push(plane);
                    });
                };
                reader.readAsDataURL(files[i]);
            }
        });

        /** 
         * MEDIAPIPE HAND GESTURES 
         **/
        const videoElement = document.getElementById('input_video');
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(results => {
            document.getElementById('loading').style.display = 'none';
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks;
                
                // One hand movement (Rotation)
                const hand1 = landmarks[0];
                handData.rotation.y = (hand1[0].x - 0.5) * 4;
                handData.rotation.x = (hand1[0].y - 0.5) * 4;

                // Pinch detection (Index tip to Thumb tip)
                const distPinch = Math.hypot(hand1[8].x - hand1[4].x, hand1[8].y - hand1[4].y);
                handData.scale = THREE.MathUtils.lerp(handData.scale, distPinch < 0.1 ? 0.5 : 1.2, 0.1);

                // Two hand logic (Spread/Explode)
                if (landmarks.length === 2) {
                    const hand2 = landmarks[1];
                    const distHands = Math.hypot(hand1[0].x - hand2[0].x, hand1[0].y - hand2[0].y);
                    handData.spread = THREE.MathUtils.lerp(handData.spread, distHands * 50, 0.1);
                } else {
                    handData.spread = THREE.MathUtils.lerp(handData.spread, 0, 0.05);
                }
            }
        });

        const cameraTracking = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraTracking.start();

        /** 
         * ANIMATION LOOP 
         **/
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            
            const positions = particleSystem.geometry.attributes.position.array;
            
            // Update UI based values
            particleSystem.material.size = parseFloat(document.getElementById('pSize').value);
            particleSystem.material.color.set(document.getElementById('colorPicker').value);

            // Morphing and Gesture Reaction
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const target = targetPositions[i];
                
                // Base morphing
                positions[i3] += (target.x - positions[i3]) * 0.05;
                positions[i3+1] += (target.y - positions[i3+1]) * 0.05;
                positions[i3+2] += (target.z - positions[i3+2]) * 0.05;

                // Add "Explode" spread from gestures
                if (handData.spread > 2) {
                    positions[i3] += (Math.random() - 0.5) * handData.spread * 0.1;
                    positions[i3+1] += (Math.random() - 0.5) * handData.spread * 0.1;
                    positions[i3+2] += (Math.random() - 0.5) * handData.spread * 0.1;
                }
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;

            // Apply gesture rotation & scale
            particleSystem.rotation.y += (handData.rotation.y - particleSystem.rotation.y) * 0.1;
            particleSystem.rotation.x += (handData.rotation.x - particleSystem.rotation.x) * 0.1;
            const s = handData.scale;
            particleSystem.scale.set(s, s, s);

            // Animate Photo Planes
            photoPlanes.forEach((p, idx) => {
                p.position.y = Math.sin(time + idx) * 0.5;
                p.lookAt(camera.position);
            });

            // Twinkle effect
            if (Math.random() > 0.8) {
                particleSystem.material.opacity = 0.8 + Math.random() * 0.2;
            }

            renderer.render(scene, camera);
        }

        /** 
         * UI EVENTS 
         **/
        document.getElementById('shapeSelect').addEventListener('change', (e) => {
            targetPositions = getShapePoints(e.target.value);
        });

        document.getElementById('calibrateBtn').addEventListener('click', () => {
            handData.rotation = {x:0, y:0};
            particleSystem.rotation.set(0,0,0);
        });

        // Initialize and Start
        initThree();
        animate();

    </script>
</body>
</html>